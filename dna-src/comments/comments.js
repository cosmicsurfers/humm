// -----------------------------------------------------------------
//  This stub Zome code file was auto-generated by hc-scaffold
// -----------------------------------------------------------------

// -----------------------------------------------------------------
//  Exposed functions with custom logic https://developer.holochain.org/API_reference
// -----------------------------------------------------------------

function commentCreate (commentEntry) {
  commentEntry.uuid = generateUUIDv4();
  commentEntry.createdAt = new Date();
  commentEntry.deleted = false;
  commentEntry.updatedAt = new Date();
  const commentHash = commit('comment', commentEntry);
  commentEntry.hash = commentHash;
  createCommentPostLink(commentEntry);
  createCommentAuthorLink(commentEntry);
  return commentHash;
}

function commentRead (commentHash) {
  return get(commentHash);
}

// TODO: function not implemented
function commentUpdate (commentHash) {
  const sampleValue = {
    uuid: '3d97d337-1444-4104-b1b4-c48e9404e8db',
    rootParentId: '598a94b9-0225-4ee1-85a9-46dd7a4497ab',
    parentId: '28fcbff4-8d2f-494c-a2c5-9dd845f1ab5a',
    body: 'I enjoyed reading this article because it was well written.',
    author: 'Pablo Picapiedra',
    createdAt: '2018-11-11',
    updatedAt: '2018-11-12'
  };
  const commentOutHash = update('comment', sampleValue, commentHash);
  return commentOutHash;
}

function commentDelete (commentObj) {
  const comments = getLinkedComments(commentObj.parentId);
  const comment = comments.filter(item => item.Hash === commentObj.hash);

  if (comment.length !== 0) {
    comment[0].Entry.deleted = true;
    comment[0].Entry.updatedAt = new Date();

    const updatedComment = update('comment', comment[0].Entry, comment[0].Hash);

    commit('comment_post_link', {
      Links: [
        {
          Base: anchor('comment', commentObj.parentId),
          Link: comment[0].Hash,
          Tag: 'comment',
          LinkAction: HC.LinkAction.Del
        }
      ]
    });

    commit('comment_post_link', {
      Links: [{
        Base: anchor('comment', commentObj.parentId),
        Link: updatedComment,
        Tag: 'comment'
      }]
    });
    return 'Comment Marked as Deleted';
  }
  return 'Comment not Found or Marked as Deleted';
}

function getLinkedComments(parentId) {
  return getLinks(anchor('comment', parentId), 'comment', {Load: true});
}

function createCommentPostLink(comment) {
  commit('comment_post_link', {
    Links: [{
      Base: anchor('comment', comment.parentId),
      Link: comment.hash,
      Tag: 'comment'
    }]
  });
}

function createCommentAuthorLink(comment) {
  commit('comment_author_link', {
    Links: [{
      Base: anchor('comment', comment.author),
      Link: comment.hash,
      Tag: 'comment'
    }]
  });
}

// UUIDv4 credit: https://gist.github.com/LeverOne/1308368
function generateUUIDv4(a, b) {
for(b=a='';a++<36;b+=a*51&52?(a^15?8^Math.random()*(a^20?16:4):4).toString(16):'-');
return b;
}

// -----------------------------------------------------------------
//  TODO
// -----------------------------------------------------------------

function commentUpdate (commentHash) {
  const sampleValue = {
    uuid: '3d97d337-1444-4104-b1b4-c48e9404e8db',
    rootParentId: '598a94b9-0225-4ee1-85a9-46dd7a4497ab',
    parentId: '28fcbff4-8d2f-494c-a2c5-9dd845f1ab5a',
    body: 'I enjoyed reading this article because it was well written.',
    author: 'Pablo Picapiedra',
    createdAt: '2018-11-11',
    updatedAt: '2018-11-12'
  };
  const commentOutHash = update('comment', sampleValue, commentHash);
  return commentOutHash;
}

// -----------------------------------------------------------------
//  Mixins
// -----------------------------------------------------------------

function anchor(anchorType, anchorText) {
  return call('anchors', 'anchor', {
    anchorType: anchorType,
    anchorText: anchorText
  }).replace(/"/g, '');
}

function anchorExists(anchorType, anchorText) {
  return call('anchors', 'exists', {
    anchorType: anchorType,
    anchorText: anchorText
  });
}

// -----------------------------------------------------------------
//  The Genesis Function https://developer.holochain.org/genesis
// -----------------------------------------------------------------

/**
 * Called only when your source chain is generated
 * @return {boolean} success
 */
function genesis () {
  return true;
}

// -----------------------------------------------------------------
//  Validation functions for every change to the local chain or DHT
// -----------------------------------------------------------------

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateCommit (entryName, entry, header, pkg, sources) {
  return true;
  switch (entryName) {
    case 'comment':
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return false;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validatePut (entryName, entry, header, pkg, sources) {
  return true;
  switch (entryName) {
    case 'comment':
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return false;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {*} entry - the entry data to be set
 * @param {object} header - header for the entry containing properties EntryLink, Time, and Type
 * @param {string} replaces - the hash for the entry being updated
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateMod (entryName, entry, header, replaces, pkg, sources) {
  return true;
  switch (entryName) {
    case 'comment':
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return false;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} hash - the hash of the entry to remove
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateDel (entryName, hash, pkg, sources) {
  return true;
  switch (entryName) {
    case 'comment':
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return false;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to validate any changes to the local chain or DHT
 * @param {string} entryName - the type of entry
 * @param {string} baseHash - the hash of the base entry being linked
 * @param {?} links - ?
 * @param {*} pkg - the extra data provided by the validate[X]Pkg methods
 * @param {object} sources - an array of strings containing the keys of any authors of this entry
 * @return {boolean} is valid?
 */
function validateLink (entryName, baseHash, links, pkg, sources) {
  return true;
  switch (entryName) {
    case 'comment':
      // be sure to consider many edge cases for validating
      // do not just flip this to true without considering what that means
      // the action will ONLY be successfull if this returns true, so watch out!
      return false;
    default:
      // invalid entry name
      return false;
  }
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validatePutPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateModPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateDelPkg (entryName) {
  return null;
}

/**
 * Called to get the data needed to validate
 * @param {string} entryName - the name of entry to validate
 * @return {*} the data required for validation
 */
function validateLinkPkg (entryName) {
  return null;
}
